{"ast":null,"code":"module.exports = Extract;\n\nvar Parse = require('./parse');\n\nvar Writer = require('fstream').Writer;\n\nvar util = require('util');\n\nvar path = require('path');\n\nutil.inherits(Extract, Parse);\n\nfunction Extract(opts) {\n  if (!(this instanceof Extract)) return new Extract(opts);\n  var self = this;\n  var finishCb;\n  var pending = 0;\n\n  var _final = typeof this._final === 'function' ? this._final : undefined;\n\n  function checkFinished() {\n    if (pending === 0 && finishCb) {\n      _final ? _final(finishCb) : finishCb();\n    }\n  }\n\n  this._final = function (cb) {\n    finishCb = cb;\n    checkFinished();\n  }; // make sure path is normalized before using it\n\n\n  opts.path = path.normalize(opts.path);\n  Parse.call(self, opts);\n  self.on('entry', function (entry) {\n    if (entry.type == 'Directory') return; // to avoid zip slip (writing outside of the destination), we resolve\n    // the target path, and make sure it's nested in the intended\n    // destination, or not extract it otherwise.\n\n    var extractPath = path.join(opts.path, entry.path);\n\n    if (extractPath.indexOf(opts.path) != 0) {\n      return;\n    }\n\n    const writer = opts.getWriter ? opts.getWriter({\n      path: extractPath\n    }) : Writer({\n      path: extractPath\n    });\n    pending += 1;\n    entry.pipe(writer).on('error', function (e) {\n      self.emit('error', e);\n      pending -= 1;\n      checkFinished();\n    }).on('close', function () {\n      pending -= 1;\n      checkFinished();\n    });\n  });\n}","map":{"version":3,"sources":["C:/TechQuartier/TechTalents/visibleImpact/visibleimpactapp/node_modules/unzipper/lib/extract.js"],"names":["module","exports","Extract","Parse","require","Writer","util","path","inherits","opts","self","finishCb","pending","_final","undefined","checkFinished","cb","normalize","call","on","entry","type","extractPath","join","indexOf","writer","getWriter","pipe","e","emit"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBC,MAAhC;;AACA,IAAIC,IAAI,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAAlB;;AAEAE,IAAI,CAACE,QAAL,CAAcN,OAAd,EAAuBC,KAAvB;;AAEA,SAASD,OAAT,CAAkBO,IAAlB,EAAwB;AACtB,MAAI,EAAE,gBAAgBP,OAAlB,CAAJ,EACE,OAAO,IAAIA,OAAJ,CAAYO,IAAZ,CAAP;AAEF,MAAIC,IAAI,GAAG,IAAX;AAEA,MAAIC,QAAJ;AACA,MAAIC,OAAO,GAAG,CAAd;;AACA,MAAIC,MAAM,GAAG,OAAO,KAAKA,MAAZ,KAAuB,UAAvB,GAAoC,KAAKA,MAAzC,GAAkDC,SAA/D;;AAEA,WAASC,aAAT,GAAyB;AACvB,QAAIH,OAAO,KAAK,CAAZ,IAAiBD,QAArB,EAA+B;AAC7BE,MAAAA,MAAM,GAAGA,MAAM,CAACF,QAAD,CAAT,GAAsBA,QAAQ,EAApC;AACD;AACF;;AAED,OAAKE,MAAL,GAAc,UAASG,EAAT,EAAa;AACzBL,IAAAA,QAAQ,GAAGK,EAAX;AACAD,IAAAA,aAAa;AACd,GAHD,CAhBsB,CAqBtB;;;AACAN,EAAAA,IAAI,CAACF,IAAL,GAAYA,IAAI,CAACU,SAAL,CAAeR,IAAI,CAACF,IAApB,CAAZ;AAEAJ,EAAAA,KAAK,CAACe,IAAN,CAAWR,IAAX,EAAgBD,IAAhB;AAEAC,EAAAA,IAAI,CAACS,EAAL,CAAQ,OAAR,EAAiB,UAASC,KAAT,EAAgB;AAC/B,QAAIA,KAAK,CAACC,IAAN,IAAc,WAAlB,EAA+B,OADA,CAG/B;AACA;AACA;;AACA,QAAIC,WAAW,GAAGf,IAAI,CAACgB,IAAL,CAAUd,IAAI,CAACF,IAAf,EAAqBa,KAAK,CAACb,IAA3B,CAAlB;;AACA,QAAIe,WAAW,CAACE,OAAZ,CAAoBf,IAAI,CAACF,IAAzB,KAAkC,CAAtC,EAAyC;AACvC;AACD;;AAED,UAAMkB,MAAM,GAAGhB,IAAI,CAACiB,SAAL,GAAiBjB,IAAI,CAACiB,SAAL,CAAe;AAACnB,MAAAA,IAAI,EAAEe;AAAP,KAAf,CAAjB,GAAwDjB,MAAM,CAAC;AAAEE,MAAAA,IAAI,EAAEe;AAAR,KAAD,CAA7E;AAEAV,IAAAA,OAAO,IAAI,CAAX;AACAQ,IAAAA,KAAK,CAACO,IAAN,CAAWF,MAAX,EACCN,EADD,CACI,OADJ,EACY,UAASS,CAAT,EAAY;AACtBlB,MAAAA,IAAI,CAACmB,IAAL,CAAU,OAAV,EAAkBD,CAAlB;AACAhB,MAAAA,OAAO,IAAI,CAAX;AACAG,MAAAA,aAAa;AACd,KALD,EAMCI,EAND,CAMI,OANJ,EAMa,YAAW;AACtBP,MAAAA,OAAO,IAAI,CAAX;AACAG,MAAAA,aAAa;AACd,KATD;AAUD,GAxBD;AAyBD","sourcesContent":["module.exports = Extract;\n\nvar Parse = require('./parse');\nvar Writer = require('fstream').Writer;\nvar util = require('util');\nvar path = require('path');\n\nutil.inherits(Extract, Parse);\n\nfunction Extract (opts) {\n  if (!(this instanceof Extract))\n    return new Extract(opts);\n\n  var self = this;\n  \n  var finishCb;\n  var pending = 0;\n  var _final = typeof this._final === 'function' ? this._final : undefined;\n\n  function checkFinished() {\n    if (pending === 0 && finishCb) {\n      _final ? _final(finishCb) : finishCb();\n    }\n  }\n\n  this._final = function(cb) {\n    finishCb = cb;\n    checkFinished();\n  };\n\n  // make sure path is normalized before using it\n  opts.path = path.normalize(opts.path);\n\n  Parse.call(self,opts);\n\n  self.on('entry', function(entry) {\n    if (entry.type == 'Directory') return;\n\n    // to avoid zip slip (writing outside of the destination), we resolve\n    // the target path, and make sure it's nested in the intended\n    // destination, or not extract it otherwise.\n    var extractPath = path.join(opts.path, entry.path);\n    if (extractPath.indexOf(opts.path) != 0) {\n      return;\n    }\n\n    const writer = opts.getWriter ? opts.getWriter({path: extractPath}) :  Writer({ path: extractPath });\n\n    pending += 1;\n    entry.pipe(writer)\n    .on('error',function(e) {\n      self.emit('error',e);\n      pending -= 1;\n      checkFinished();\n    })\n    .on('close', function() {\n      pending -= 1;\n      checkFinished();\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"script"}