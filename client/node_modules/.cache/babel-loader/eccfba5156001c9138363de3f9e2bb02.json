{"ast":null,"code":"var util = require('util');\n\nvar zlib = require('zlib');\n\nvar Stream = require('stream');\n\nvar binary = require('binary');\n\nvar Promise = require('bluebird');\n\nvar PullStream = require('./PullStream');\n\nvar NoopStream = require('./NoopStream');\n\nvar BufferStream = require('./BufferStream');\n\nvar parseExtraField = require('./parseExtraField');\n\nvar Buffer = require('./Buffer'); // Backwards compatibility for node versions < 8\n\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\nvar endDirectorySignature = Buffer.alloc(4);\nendDirectorySignature.writeUInt32LE(0x06054b50, 0);\n\nfunction Parse(opts) {\n  if (!(this instanceof Parse)) {\n    return new Parse(opts);\n  }\n\n  var self = this;\n  self._opts = opts || {\n    verbose: false\n  };\n  PullStream.call(self, self._opts);\n  self.on('finish', function () {\n    self.emit('close');\n  });\n\n  self._readRecord().catch(function (e) {\n    if (!self.__emittedError || self.__emittedError !== e) self.emit('error', e);\n  });\n}\n\nutil.inherits(Parse, PullStream);\n\nParse.prototype._readRecord = function () {\n  var self = this;\n  return self.pull(4).then(function (data) {\n    if (data.length === 0) return;\n    var signature = data.readUInt32LE(0);\n\n    if (signature === 0x04034b50) {\n      return self._readFile();\n    } else if (signature === 0x02014b50) {\n      self.__ended = true;\n      return self._readCentralDirectoryFileHeader();\n    } else if (signature === 0x06054b50) {\n      return self._readEndOfCentralDirectoryRecord();\n    } else if (self.__ended) {\n      return self.pull(endDirectorySignature).then(function () {\n        return self._readEndOfCentralDirectoryRecord();\n      });\n    } else self.emit('error', new Error('invalid signature: 0x' + signature.toString(16)));\n  });\n};\n\nParse.prototype._readFile = function () {\n  var self = this;\n  return self.pull(26).then(function (data) {\n    var vars = binary.parse(data).word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').vars;\n    return self.pull(vars.fileNameLength).then(function (fileNameBuffer) {\n      fileName = fileNameBuffer.toString('utf8');\n      var entry = Stream.PassThrough();\n      var __autodraining = false;\n\n      entry.autodrain = function () {\n        __autodraining = true;\n        var draining = entry.pipe(NoopStream());\n\n        draining.promise = function () {\n          return new Promise(function (resolve, reject) {\n            draining.on('finish', resolve);\n            draining.on('error', reject);\n          });\n        };\n\n        return draining;\n      };\n\n      entry.buffer = function () {\n        return BufferStream(entry);\n      };\n\n      entry.path = fileName;\n      entry.props = {};\n      entry.props.path = fileName;\n      entry.props.pathBuffer = fileNameBuffer;\n      entry.props.flags = {\n        \"isUnicode\": vars.flags & 0x11\n      };\n      entry.type = vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(fileName) ? 'Directory' : 'File';\n\n      if (self._opts.verbose) {\n        if (entry.type === 'Directory') {\n          console.log('   creating:', fileName);\n        } else if (entry.type === 'File') {\n          if (vars.compressionMethod === 0) {\n            console.log(' extracting:', fileName);\n          } else {\n            console.log('  inflating:', fileName);\n          }\n        }\n      }\n\n      return self.pull(vars.extraFieldLength).then(function (extraField) {\n        var extra = parseExtraField(extraField, vars);\n        entry.vars = vars;\n        entry.extra = extra;\n        self.emit('entry', entry);\n        if (self._readableState.pipesCount) self.push(entry);\n        if (self._opts.verbose) console.log({\n          filename: fileName,\n          vars: vars,\n          extra: extra\n        });\n        var fileSizeKnown = !(vars.flags & 0x08),\n            eof;\n        entry.__autodraining = __autodraining; // expose __autodraining for test purposes\n\n        var inflater = vars.compressionMethod && !__autodraining ? zlib.createInflateRaw() : Stream.PassThrough();\n\n        if (fileSizeKnown) {\n          entry.size = vars.uncompressedSize;\n          eof = vars.compressedSize;\n        } else {\n          eof = Buffer.alloc(4);\n          eof.writeUInt32LE(0x08074b50, 0);\n        }\n\n        self.stream(eof).pipe(inflater).on('error', function (err) {\n          self.emit('error', err);\n        }).pipe(entry).on('finish', function () {\n          return fileSizeKnown ? self._readRecord() : self._processDataDescriptor(entry);\n        });\n        return null; // This prevents bluebird from throwing \"promise created but not returned\" warnings\n      });\n    });\n  });\n};\n\nParse.prototype._processDataDescriptor = function (entry) {\n  var self = this;\n  self.pull(16).then(function (data) {\n    var vars = binary.parse(data).word32lu('dataDescriptorSignature').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').vars;\n    entry.size = vars.uncompressedSize;\n\n    self._readRecord();\n  });\n};\n\nParse.prototype._readCentralDirectoryFileHeader = function () {\n  var self = this;\n  self.pull(42).then(function (data) {\n    var vars = binary.parse(data).word16lu('versionMadeBy').word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').word16lu('fileCommentLength').word16lu('diskNumber').word16lu('internalFileAttributes').word32lu('externalFileAttributes').word32lu('offsetToLocalFileHeader').vars;\n    return self.pull(vars.fileNameLength).then(function (fileName) {\n      vars.fileName = fileName.toString('utf8');\n      return self.pull(vars.extraFieldLength);\n    }).then(function (extraField) {\n      return self.pull(vars.fileCommentLength);\n    }).then(function (fileComment) {\n      return self._readRecord();\n    });\n  });\n};\n\nParse.prototype._readEndOfCentralDirectoryRecord = function () {\n  var self = this;\n  self.pull(18).then(function (data) {\n    var vars = binary.parse(data).word16lu('diskNumber').word16lu('diskStart').word16lu('numberOfRecordsOnDisk').word16lu('numberOfRecords').word32lu('sizeOfCentralDirectory').word32lu('offsetToStartOfCentralDirectory').word16lu('commentLength').vars;\n    self.pull(vars.commentLength).then(function (comment) {\n      comment = comment.toString('utf8');\n      self.end();\n      self.push(null);\n    });\n  });\n};\n\nParse.prototype.promise = function () {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    self.on('finish', resolve);\n    self.on('error', reject);\n  });\n};\n\nmodule.exports = Parse;","map":{"version":3,"sources":["C:/TechQuartier/TechTalents/visibleImpact/visibleimpactapp/node_modules/unzipper/lib/parse.js"],"names":["util","require","zlib","Stream","binary","Promise","PullStream","NoopStream","BufferStream","parseExtraField","Buffer","Writable","prototype","destroy","endDirectorySignature","alloc","writeUInt32LE","Parse","opts","self","_opts","verbose","call","on","emit","_readRecord","catch","e","__emittedError","inherits","pull","then","data","length","signature","readUInt32LE","_readFile","__ended","_readCentralDirectoryFileHeader","_readEndOfCentralDirectoryRecord","Error","toString","vars","parse","word16lu","word32lu","fileNameLength","fileNameBuffer","fileName","entry","PassThrough","__autodraining","autodrain","draining","pipe","promise","resolve","reject","buffer","path","props","pathBuffer","flags","type","uncompressedSize","test","console","log","compressionMethod","extraFieldLength","extraField","extra","_readableState","pipesCount","push","filename","fileSizeKnown","eof","inflater","createInflateRaw","size","compressedSize","stream","err","_processDataDescriptor","fileCommentLength","fileComment","commentLength","comment","end","module","exports"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAApB;;AACA,IAAII,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAArB;;AACA,IAAIK,UAAU,GAAGL,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIM,UAAU,GAAGN,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIO,YAAY,GAAGP,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAIQ,eAAe,GAAGR,OAAO,CAAC,mBAAD,CAA7B;;AACA,IAAIS,MAAM,GAAGT,OAAO,CAAC,UAAD,CAApB,C,CAEA;;;AACA,IAAI,CAACE,MAAM,CAACQ,QAAR,IAAoB,CAACR,MAAM,CAACQ,QAAP,CAAgBC,SAAhB,CAA0BC,OAAnD,EACEV,MAAM,GAAGF,OAAO,CAAC,iBAAD,CAAhB;AAEF,IAAIa,qBAAqB,GAAGJ,MAAM,CAACK,KAAP,CAAa,CAAb,CAA5B;AACAD,qBAAqB,CAACE,aAAtB,CAAoC,UAApC,EAAgD,CAAhD;;AAEA,SAASC,KAAT,CAAeC,IAAf,EAAqB;AACnB,MAAI,EAAE,gBAAgBD,KAAlB,CAAJ,EAA8B;AAC5B,WAAO,IAAIA,KAAJ,CAAUC,IAAV,CAAP;AACD;;AACD,MAAIC,IAAI,GAAG,IAAX;AACAA,EAAAA,IAAI,CAACC,KAAL,GAAaF,IAAI,IAAI;AAAEG,IAAAA,OAAO,EAAE;AAAX,GAArB;AAEAf,EAAAA,UAAU,CAACgB,IAAX,CAAgBH,IAAhB,EAAsBA,IAAI,CAACC,KAA3B;AACAD,EAAAA,IAAI,CAACI,EAAL,CAAQ,QAAR,EAAiB,YAAW;AAC1BJ,IAAAA,IAAI,CAACK,IAAL,CAAU,OAAV;AACD,GAFD;;AAGAL,EAAAA,IAAI,CAACM,WAAL,GAAmBC,KAAnB,CAAyB,UAASC,CAAT,EAAY;AACnC,QAAI,CAACR,IAAI,CAACS,cAAN,IAAwBT,IAAI,CAACS,cAAL,KAAwBD,CAApD,EACER,IAAI,CAACK,IAAL,CAAU,OAAV,EAAkBG,CAAlB;AACH,GAHD;AAID;;AAED3B,IAAI,CAAC6B,QAAL,CAAcZ,KAAd,EAAqBX,UAArB;;AAEAW,KAAK,CAACL,SAAN,CAAgBa,WAAhB,GAA8B,YAAY;AACxC,MAAIN,IAAI,GAAG,IAAX;AACA,SAAOA,IAAI,CAACW,IAAL,CAAU,CAAV,EAAaC,IAAb,CAAkB,UAASC,IAAT,EAAe;AACtC,QAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EACE;AAEF,QAAIC,SAAS,GAAGF,IAAI,CAACG,YAAL,CAAkB,CAAlB,CAAhB;;AAEA,QAAID,SAAS,KAAK,UAAlB,EAA8B;AAC5B,aAAOf,IAAI,CAACiB,SAAL,EAAP;AACD,KAFD,MAGK,IAAIF,SAAS,KAAK,UAAlB,EAA8B;AACjCf,MAAAA,IAAI,CAACkB,OAAL,GAAe,IAAf;AACA,aAAOlB,IAAI,CAACmB,+BAAL,EAAP;AACD,KAHI,MAIA,IAAIJ,SAAS,KAAK,UAAlB,EAA8B;AACjC,aAAOf,IAAI,CAACoB,gCAAL,EAAP;AACD,KAFI,MAGA,IAAIpB,IAAI,CAACkB,OAAT,EAAkB;AACrB,aAAOlB,IAAI,CAACW,IAAL,CAAUhB,qBAAV,EAAiCiB,IAAjC,CAAsC,YAAW;AACpD,eAAOZ,IAAI,CAACoB,gCAAL,EAAP;AACD,OAFI,CAAP;AAGD,KAJI,MAMHpB,IAAI,CAACK,IAAL,CAAU,OAAV,EAAmB,IAAIgB,KAAJ,CAAU,0BAA0BN,SAAS,CAACO,QAAV,CAAmB,EAAnB,CAApC,CAAnB;AACH,GAvBM,CAAP;AAwBD,CA1BD;;AA4BAxB,KAAK,CAACL,SAAN,CAAgBwB,SAAhB,GAA4B,YAAY;AACtC,MAAIjB,IAAI,GAAG,IAAX;AACA,SAAOA,IAAI,CAACW,IAAL,CAAU,EAAV,EAAcC,IAAd,CAAmB,UAASC,IAAT,EAAe;AACvC,QAAIU,IAAI,GAAGtC,MAAM,CAACuC,KAAP,CAAaX,IAAb,EACRY,QADQ,CACC,yBADD,EAERA,QAFQ,CAEC,OAFD,EAGRA,QAHQ,CAGC,mBAHD,EAIRA,QAJQ,CAIC,kBAJD,EAKRA,QALQ,CAKC,kBALD,EAMRC,QANQ,CAMC,OAND,EAORA,QAPQ,CAOC,gBAPD,EAQRA,QARQ,CAQC,kBARD,EASRD,QATQ,CASC,gBATD,EAURA,QAVQ,CAUC,kBAVD,EAWRF,IAXH;AAaA,WAAOvB,IAAI,CAACW,IAAL,CAAUY,IAAI,CAACI,cAAf,EAA+Bf,IAA/B,CAAoC,UAASgB,cAAT,EAAyB;AAClEC,MAAAA,QAAQ,GAAGD,cAAc,CAACN,QAAf,CAAwB,MAAxB,CAAX;AACA,UAAIQ,KAAK,GAAG9C,MAAM,CAAC+C,WAAP,EAAZ;AACA,UAAIC,cAAc,GAAG,KAArB;;AAEAF,MAAAA,KAAK,CAACG,SAAN,GAAkB,YAAW;AAC3BD,QAAAA,cAAc,GAAG,IAAjB;AACA,YAAIE,QAAQ,GAAGJ,KAAK,CAACK,IAAN,CAAW/C,UAAU,EAArB,CAAf;;AACA8C,QAAAA,QAAQ,CAACE,OAAT,GAAmB,YAAW;AAC5B,iBAAO,IAAIlD,OAAJ,CAAY,UAASmD,OAAT,EAAkBC,MAAlB,EAA0B;AAC3CJ,YAAAA,QAAQ,CAAC9B,EAAT,CAAY,QAAZ,EAAqBiC,OAArB;AACAH,YAAAA,QAAQ,CAAC9B,EAAT,CAAY,OAAZ,EAAoBkC,MAApB;AACD,WAHM,CAAP;AAID,SALD;;AAMA,eAAOJ,QAAP;AACD,OAVD;;AAYAJ,MAAAA,KAAK,CAACS,MAAN,GAAe,YAAW;AACxB,eAAOlD,YAAY,CAACyC,KAAD,CAAnB;AACD,OAFD;;AAIAA,MAAAA,KAAK,CAACU,IAAN,GAAaX,QAAb;AACAC,MAAAA,KAAK,CAACW,KAAN,GAAc,EAAd;AACAX,MAAAA,KAAK,CAACW,KAAN,CAAYD,IAAZ,GAAmBX,QAAnB;AACAC,MAAAA,KAAK,CAACW,KAAN,CAAYC,UAAZ,GAAyBd,cAAzB;AACAE,MAAAA,KAAK,CAACW,KAAN,CAAYE,KAAZ,GAAoB;AAClB,qBAAapB,IAAI,CAACoB,KAAL,GAAa;AADR,OAApB;AAGAb,MAAAA,KAAK,CAACc,IAAN,GAAcrB,IAAI,CAACsB,gBAAL,KAA0B,CAA1B,IAA+B,UAAUC,IAAV,CAAejB,QAAf,CAAhC,GAA4D,WAA5D,GAA0E,MAAvF;;AAEA,UAAI7B,IAAI,CAACC,KAAL,CAAWC,OAAf,EAAwB;AACtB,YAAI4B,KAAK,CAACc,IAAN,KAAe,WAAnB,EAAgC;AAC9BG,UAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ,EAA4BnB,QAA5B;AACD,SAFD,MAEO,IAAIC,KAAK,CAACc,IAAN,KAAe,MAAnB,EAA2B;AAChC,cAAIrB,IAAI,CAAC0B,iBAAL,KAA2B,CAA/B,EAAkC;AAChCF,YAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ,EAA4BnB,QAA5B;AACD,WAFD,MAEO;AACLkB,YAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ,EAA4BnB,QAA5B;AACD;AACF;AACF;;AAED,aAAO7B,IAAI,CAACW,IAAL,CAAUY,IAAI,CAAC2B,gBAAf,EAAiCtC,IAAjC,CAAsC,UAASuC,UAAT,EAAqB;AAChE,YAAIC,KAAK,GAAG9D,eAAe,CAAC6D,UAAD,EAAa5B,IAAb,CAA3B;AAEAO,QAAAA,KAAK,CAACP,IAAN,GAAaA,IAAb;AACAO,QAAAA,KAAK,CAACsB,KAAN,GAAcA,KAAd;AAEApD,QAAAA,IAAI,CAACK,IAAL,CAAU,OAAV,EAAmByB,KAAnB;AAEA,YAAI9B,IAAI,CAACqD,cAAL,CAAoBC,UAAxB,EACEtD,IAAI,CAACuD,IAAL,CAAUzB,KAAV;AAEF,YAAI9B,IAAI,CAACC,KAAL,CAAWC,OAAf,EACE6C,OAAO,CAACC,GAAR,CAAY;AACVQ,UAAAA,QAAQ,EAAC3B,QADC;AAEVN,UAAAA,IAAI,EAAEA,IAFI;AAGV6B,UAAAA,KAAK,EAAEA;AAHG,SAAZ;AAMF,YAAIK,aAAa,GAAG,EAAElC,IAAI,CAACoB,KAAL,GAAa,IAAf,CAApB;AAAA,YACIe,GADJ;AAGA5B,QAAAA,KAAK,CAACE,cAAN,GAAuBA,cAAvB,CArBgE,CAqBxB;;AACxC,YAAI2B,QAAQ,GAAIpC,IAAI,CAAC0B,iBAAL,IAA0B,CAACjB,cAA5B,GAA8CjD,IAAI,CAAC6E,gBAAL,EAA9C,GAAwE5E,MAAM,CAAC+C,WAAP,EAAvF;;AAEA,YAAI0B,aAAJ,EAAmB;AACjB3B,UAAAA,KAAK,CAAC+B,IAAN,GAAatC,IAAI,CAACsB,gBAAlB;AACAa,UAAAA,GAAG,GAAGnC,IAAI,CAACuC,cAAX;AACD,SAHD,MAGO;AACLJ,UAAAA,GAAG,GAAGnE,MAAM,CAACK,KAAP,CAAa,CAAb,CAAN;AACA8D,UAAAA,GAAG,CAAC7D,aAAJ,CAAkB,UAAlB,EAA8B,CAA9B;AACD;;AAEDG,QAAAA,IAAI,CAAC+D,MAAL,CAAYL,GAAZ,EACGvB,IADH,CACQwB,QADR,EAEGvD,EAFH,CAEM,OAFN,EAEc,UAAS4D,GAAT,EAAc;AAAEhE,UAAAA,IAAI,CAACK,IAAL,CAAU,OAAV,EAAkB2D,GAAlB;AAAwB,SAFtD,EAGG7B,IAHH,CAGQL,KAHR,EAIG1B,EAJH,CAIM,QAJN,EAIgB,YAAW;AACvB,iBAAOqD,aAAa,GAAGzD,IAAI,CAACM,WAAL,EAAH,GAAwBN,IAAI,CAACiE,sBAAL,CAA4BnC,KAA5B,CAA5C;AACD,SANH;AAOA,eAAO,IAAP,CAvCgE,CAuCnD;AACd,OAxCM,CAAP;AAyCD,KAnFM,CAAP;AAoFD,GAlGM,CAAP;AAmGD,CArGD;;AAuGAhC,KAAK,CAACL,SAAN,CAAgBwE,sBAAhB,GAAyC,UAAUnC,KAAV,EAAiB;AACxD,MAAI9B,IAAI,GAAG,IAAX;AACAA,EAAAA,IAAI,CAACW,IAAL,CAAU,EAAV,EAAcC,IAAd,CAAmB,UAASC,IAAT,EAAe;AAChC,QAAIU,IAAI,GAAGtC,MAAM,CAACuC,KAAP,CAAaX,IAAb,EACRa,QADQ,CACC,yBADD,EAERA,QAFQ,CAEC,OAFD,EAGRA,QAHQ,CAGC,gBAHD,EAIRA,QAJQ,CAIC,kBAJD,EAKRH,IALH;AAOAO,IAAAA,KAAK,CAAC+B,IAAN,GAAatC,IAAI,CAACsB,gBAAlB;;AACA7C,IAAAA,IAAI,CAACM,WAAL;AACD,GAVD;AAWD,CAbD;;AAeAR,KAAK,CAACL,SAAN,CAAgB0B,+BAAhB,GAAkD,YAAY;AAC5D,MAAInB,IAAI,GAAG,IAAX;AACAA,EAAAA,IAAI,CAACW,IAAL,CAAU,EAAV,EAAcC,IAAd,CAAmB,UAASC,IAAT,EAAe;AAEhC,QAAIU,IAAI,GAAGtC,MAAM,CAACuC,KAAP,CAAaX,IAAb,EACRY,QADQ,CACC,eADD,EAERA,QAFQ,CAEC,yBAFD,EAGRA,QAHQ,CAGC,OAHD,EAIRA,QAJQ,CAIC,mBAJD,EAKRA,QALQ,CAKC,kBALD,EAMRA,QANQ,CAMC,kBAND,EAORC,QAPQ,CAOC,OAPD,EAQRA,QARQ,CAQC,gBARD,EASRA,QATQ,CASC,kBATD,EAURD,QAVQ,CAUC,gBAVD,EAWRA,QAXQ,CAWC,kBAXD,EAYRA,QAZQ,CAYC,mBAZD,EAaRA,QAbQ,CAaC,YAbD,EAcRA,QAdQ,CAcC,wBAdD,EAeRC,QAfQ,CAeC,wBAfD,EAgBRA,QAhBQ,CAgBC,yBAhBD,EAiBRH,IAjBH;AAmBA,WAAOvB,IAAI,CAACW,IAAL,CAAUY,IAAI,CAACI,cAAf,EAA+Bf,IAA/B,CAAoC,UAASiB,QAAT,EAAmB;AAC5DN,MAAAA,IAAI,CAACM,QAAL,GAAgBA,QAAQ,CAACP,QAAT,CAAkB,MAAlB,CAAhB;AACA,aAAOtB,IAAI,CAACW,IAAL,CAAUY,IAAI,CAAC2B,gBAAf,CAAP;AACD,KAHM,EAINtC,IAJM,CAID,UAASuC,UAAT,EAAqB;AACzB,aAAOnD,IAAI,CAACW,IAAL,CAAUY,IAAI,CAAC2C,iBAAf,CAAP;AACD,KANM,EAONtD,IAPM,CAOD,UAASuD,WAAT,EAAsB;AAC1B,aAAOnE,IAAI,CAACM,WAAL,EAAP;AACD,KATM,CAAP;AAUD,GA/BD;AAgCD,CAlCD;;AAoCAR,KAAK,CAACL,SAAN,CAAgB2B,gCAAhB,GAAmD,YAAW;AAC5D,MAAIpB,IAAI,GAAG,IAAX;AACAA,EAAAA,IAAI,CAACW,IAAL,CAAU,EAAV,EAAcC,IAAd,CAAmB,UAASC,IAAT,EAAe;AAEhC,QAAIU,IAAI,GAAGtC,MAAM,CAACuC,KAAP,CAAaX,IAAb,EACRY,QADQ,CACC,YADD,EAERA,QAFQ,CAEC,WAFD,EAGRA,QAHQ,CAGC,uBAHD,EAIRA,QAJQ,CAIC,iBAJD,EAKRC,QALQ,CAKC,wBALD,EAMRA,QANQ,CAMC,iCAND,EAORD,QAPQ,CAOC,eAPD,EAQRF,IARH;AAUAvB,IAAAA,IAAI,CAACW,IAAL,CAAUY,IAAI,CAAC6C,aAAf,EAA8BxD,IAA9B,CAAmC,UAASyD,OAAT,EAAkB;AACnDA,MAAAA,OAAO,GAAGA,OAAO,CAAC/C,QAAR,CAAiB,MAAjB,CAAV;AACAtB,MAAAA,IAAI,CAACsE,GAAL;AACAtE,MAAAA,IAAI,CAACuD,IAAL,CAAU,IAAV;AACD,KAJD;AAMD,GAlBD;AAmBD,CArBD;;AAuBAzD,KAAK,CAACL,SAAN,CAAgB2C,OAAhB,GAA0B,YAAW;AACnC,MAAIpC,IAAI,GAAG,IAAX;AACA,SAAO,IAAId,OAAJ,CAAY,UAASmD,OAAT,EAAiBC,MAAjB,EAAyB;AAC1CtC,IAAAA,IAAI,CAACI,EAAL,CAAQ,QAAR,EAAiBiC,OAAjB;AACArC,IAAAA,IAAI,CAACI,EAAL,CAAQ,OAAR,EAAgBkC,MAAhB;AACD,GAHM,CAAP;AAID,CAND;;AAQAiC,MAAM,CAACC,OAAP,GAAiB1E,KAAjB","sourcesContent":["var util = require('util');\nvar zlib = require('zlib');\nvar Stream = require('stream');\nvar binary = require('binary');\nvar Promise = require('bluebird');\nvar PullStream = require('./PullStream');\nvar NoopStream = require('./NoopStream');\nvar BufferStream = require('./BufferStream');\nvar parseExtraField = require('./parseExtraField');\nvar Buffer = require('./Buffer');\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = require('readable-stream');\n\nvar endDirectorySignature = Buffer.alloc(4);\nendDirectorySignature.writeUInt32LE(0x06054b50, 0);\n\nfunction Parse(opts) {\n  if (!(this instanceof Parse)) {\n    return new Parse(opts);\n  }\n  var self = this;\n  self._opts = opts || { verbose: false };\n\n  PullStream.call(self, self._opts);\n  self.on('finish',function() {\n    self.emit('close');\n  });\n  self._readRecord().catch(function(e) {\n    if (!self.__emittedError || self.__emittedError !== e)\n      self.emit('error',e);\n  });\n}\n\nutil.inherits(Parse, PullStream);\n\nParse.prototype._readRecord = function () {\n  var self = this;\n  return self.pull(4).then(function(data) {\n    if (data.length === 0)\n      return;\n\n    var signature = data.readUInt32LE(0);\n\n    if (signature === 0x04034b50) {\n      return self._readFile();\n    }\n    else if (signature === 0x02014b50) {\n      self.__ended = true;\n      return self._readCentralDirectoryFileHeader();\n    }\n    else if (signature === 0x06054b50) {\n      return self._readEndOfCentralDirectoryRecord();\n    }\n    else if (self.__ended) {\n      return self.pull(endDirectorySignature).then(function() {\n          return self._readEndOfCentralDirectoryRecord();\n        });\n    }\n    else\n      self.emit('error', new Error('invalid signature: 0x' + signature.toString(16)));\n  });\n};\n\nParse.prototype._readFile = function () {\n  var self = this;\n  return self.pull(26).then(function(data) {\n    var vars = binary.parse(data)\n      .word16lu('versionsNeededToExtract')\n      .word16lu('flags')\n      .word16lu('compressionMethod')\n      .word16lu('lastModifiedTime')\n      .word16lu('lastModifiedDate')\n      .word32lu('crc32')\n      .word32lu('compressedSize')\n      .word32lu('uncompressedSize')\n      .word16lu('fileNameLength')\n      .word16lu('extraFieldLength')\n      .vars;\n\n    return self.pull(vars.fileNameLength).then(function(fileNameBuffer) {\n      fileName = fileNameBuffer.toString('utf8');\n      var entry = Stream.PassThrough();\n      var __autodraining = false;\n      \n      entry.autodrain = function() {\n        __autodraining = true;\n        var draining = entry.pipe(NoopStream());\n        draining.promise = function() {\n          return new Promise(function(resolve, reject) {\n            draining.on('finish',resolve);\n            draining.on('error',reject);\n          });\n        };\n        return draining;\n      };\n\n      entry.buffer = function() {\n        return BufferStream(entry);\n      };\n\n      entry.path = fileName;\n      entry.props = {};\n      entry.props.path = fileName;\n      entry.props.pathBuffer = fileNameBuffer;\n      entry.props.flags = {\n        \"isUnicode\": vars.flags & 0x11\n      };\n      entry.type = (vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(fileName)) ? 'Directory' : 'File';\n\n      if (self._opts.verbose) {\n        if (entry.type === 'Directory') {\n          console.log('   creating:', fileName);\n        } else if (entry.type === 'File') {\n          if (vars.compressionMethod === 0) {\n            console.log(' extracting:', fileName);\n          } else {\n            console.log('  inflating:', fileName);\n          }\n        }\n      }\n       \n      return self.pull(vars.extraFieldLength).then(function(extraField) {\n        var extra = parseExtraField(extraField, vars);\n\n        entry.vars = vars;\n        entry.extra = extra;\n\n        self.emit('entry', entry);\n\n        if (self._readableState.pipesCount)\n          self.push(entry);\n\n        if (self._opts.verbose)\n          console.log({\n            filename:fileName,\n            vars: vars,\n            extra: extra\n          });\n\n        var fileSizeKnown = !(vars.flags & 0x08),\n            eof;\n\n        entry.__autodraining = __autodraining;  // expose __autodraining for test purposes\n        var inflater = (vars.compressionMethod && !__autodraining) ? zlib.createInflateRaw() : Stream.PassThrough();\n\n        if (fileSizeKnown) {\n          entry.size = vars.uncompressedSize;\n          eof = vars.compressedSize;\n        } else {\n          eof = Buffer.alloc(4);\n          eof.writeUInt32LE(0x08074b50, 0);\n        }\n\n        self.stream(eof)\n          .pipe(inflater)\n          .on('error',function(err) { self.emit('error',err);})\n          .pipe(entry)\n          .on('finish', function() {\n            return fileSizeKnown ? self._readRecord() : self._processDataDescriptor(entry);\n          });\n        return null; // This prevents bluebird from throwing \"promise created but not returned\" warnings\n      });\n    });\n  });\n};\n\nParse.prototype._processDataDescriptor = function (entry) {\n  var self = this;\n  self.pull(16).then(function(data) {\n    var vars = binary.parse(data)\n      .word32lu('dataDescriptorSignature')\n      .word32lu('crc32')\n      .word32lu('compressedSize')\n      .word32lu('uncompressedSize')\n      .vars;\n\n    entry.size = vars.uncompressedSize;\n    self._readRecord();\n  });\n};\n\nParse.prototype._readCentralDirectoryFileHeader = function () {\n  var self = this;\n  self.pull(42).then(function(data) {\n    \n    var vars = binary.parse(data)\n      .word16lu('versionMadeBy')\n      .word16lu('versionsNeededToExtract')\n      .word16lu('flags')\n      .word16lu('compressionMethod')\n      .word16lu('lastModifiedTime')\n      .word16lu('lastModifiedDate')\n      .word32lu('crc32')\n      .word32lu('compressedSize')\n      .word32lu('uncompressedSize')\n      .word16lu('fileNameLength')\n      .word16lu('extraFieldLength')\n      .word16lu('fileCommentLength')\n      .word16lu('diskNumber')\n      .word16lu('internalFileAttributes')\n      .word32lu('externalFileAttributes')\n      .word32lu('offsetToLocalFileHeader')\n      .vars;\n\n    return self.pull(vars.fileNameLength).then(function(fileName) {\n      vars.fileName = fileName.toString('utf8');\n      return self.pull(vars.extraFieldLength);\n    })\n    .then(function(extraField) {\n      return self.pull(vars.fileCommentLength);\n    })\n    .then(function(fileComment) {\n      return self._readRecord();\n    });\n  });\n};\n\nParse.prototype._readEndOfCentralDirectoryRecord = function() {\n  var self = this;\n  self.pull(18).then(function(data) {\n    \n    var vars = binary.parse(data)\n      .word16lu('diskNumber')\n      .word16lu('diskStart')\n      .word16lu('numberOfRecordsOnDisk')\n      .word16lu('numberOfRecords')\n      .word32lu('sizeOfCentralDirectory')\n      .word32lu('offsetToStartOfCentralDirectory')\n      .word16lu('commentLength')\n      .vars;\n\n    self.pull(vars.commentLength).then(function(comment) {\n      comment = comment.toString('utf8');\n      self.end();\n      self.push(null);\n    });\n    \n  });\n};\n\nParse.prototype.promise = function() {\n  var self = this;\n  return new Promise(function(resolve,reject) {\n    self.on('finish',resolve);\n    self.on('error',reject);\n  });\n};\n\nmodule.exports = Parse;"]},"metadata":{},"sourceType":"script"}